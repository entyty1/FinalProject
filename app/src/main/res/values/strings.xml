<resources>
    <string name="app_name">GlobalProject</string>
    <string name="lessonja_1">
        "                                   Ввод в Java."\n\n
        "Чтобы ввести значение в Java нужно:\n\n"
        "1)   Импортировать нужную бибилотеку с помощью строчки:\n\n"
        "           java.util.Scanner;\n\n"
        "2)   Обьявить сканер переменной:\n\n"
        "           Scanner sc = new Scanner(System.in)\n\n"
        "3)   Ввести переменную строчкой:\n\n"
        "           int a = sc.nextInt();\n\n"
        "Пример кода ввода:"\n\n
        "import java.util.Scanner;\n"
        "public class Main {\n"
        "    public static void main(String[] args){\n"
        "       Scanner in = new Scanner(System.in)\n"
        "       int b = in.nextInt();\n"
        "   }\n"
        "}\n"
    </string>
    <string name="lessonpy1">
        "                                   ВВЕДЕНИЕ."\n\n
        "Установка редактора кода"
        "Для работы нам понадобится редактор кода (IDE). Самые популярные:
            •	PyCharm
            •	Atom
            •	Visual Studio Code
            •	Sublime Text"\n\n
        "Онлайн-редакторы кода
        Если под рукой только смартфон, воспользуемся бесплатными онлайн-редакторами кода:
            •	repl.it
            •	onlinegdb.com
            •	tutorialspoint.com
            •	paiza.io
            •	onecompiler.com"\n\n
        Запускаем IDLE, после чего уже можно начинать писать первую программу. В открывшемся окне введите следующий код:\n
        name = input("Как Вас зовут? ")
        print("Привет,", name)
        Первая строка печатает вопрос ("Как Вас зовут? "), ожидает, пока вы не напечатаете что-нибудь и не нажмёте Enter и сохраняет введённое значение в переменной name.
        Во второй строке мы используем функцию print для вывода текста на экран, в данном случае для вывода "Привет, " и того, что хранится в переменной "name".
        Теперь запускаем программу(зеленая стрелочка) и убеждаемся, что то, что мы написали, работает.\n
        Поздравляю! Вы научились писать простейшие программы, а также познакомились со средой разработки IDLE. Теперь можно немного отдохнуть, а потом начать изучать python дальше.
    </string>
    <string name="lesson2_py">
        "                                           Синтаксис."\n\n
        "   Python использует отступы, чтобы обозначить начало блока кода:\n
                if 3 > 1:
                    print('Три больше единицы') \n
        "Python выдаст ошибку, если вы пропустите отступ:"
                if 3 > 1:
                print('Три больше единицы')  (Ошибка: IndentationError: expected an indented block)\n
        Рекомендуется использовать отступ, равный четырем пробелам или нажать на tab. Синтаксис языка Python, как и сам язык, очень прост.\n
            1)	Конец строки является концом инструкции (точка с запятой не требуется).
            2)	Вложенные инструкции в Python записываются в соответствии с одним и тем же шаблоном, когда основная инструкция завершается двоеточием, вслед за которым располагается вложенный блок кода, обычно с отступом под строкой основной инструкции.\n
        Несколько специальных случаев\n
        1)	Иногда возможно записать несколько инструкций в одной строке, разделяя их точкой с запятой:
        a = 1; b = 2; print(a, b)\n
        Но не делайте это слишком часто! Помните об удобочитаемости. А лучше вообще так не делайте.\n
        2)	Допустимо записывать одну инструкцию в нескольких строках. Достаточно ее заключить в пару круглых, квадратных или фигурных скобок:
        	if (a == 1 and b == 2 and c == 3 and d == 4):   (Не забываем про двоеточие)
                print('spam' * 3)\n
        3)	Тело составной инструкции может располагаться в той же строке, что и тело основной, если тело составной инструкции не содержит составных инструкций. Ну я думаю, вы поняли :).\n
                if x > y: print(x)\n
        Полное понимание синтаксиса, конечно, приходит с опытом."
    </string>
    <string name="lessonpy_3">
        "                               Целые числа (int)."\n\n
        Числа в Python 3 ничем не отличаются от обычных чисел. Они поддерживают набор самых обычных математических операций:\n
        1)  x + y	Сложение\n
        2)  x - y	Вычитание\n
        3)  x * y	Умножение\n
        4)  x / y	Деление\n
        5)  x // y	Получение целой части от деления\n
        6)  x % y	Остаток от деления\n
        7)  -x	Смена знака числа\n
        8)  abs(x)	Модуль числа\n
        9)  divmod(x, y)	Пара (x // y, x % y)\n
        10) x ** y	Возведение в степень\n
        11) "pow(x, y[, z])	xy по модулю (если модуль задан)"\n\n
        "Также нужно отметить, что целые числа в python 3, в отличие от многих других языков, поддерживают длинную арифметику (однако, это требует больше памяти)."\n\n
        ">>> 255 + 34"\n
        "289"\n\n
        ">>> 5 * 2"\n
        "10"\n\n
        ">>> 20 / 3"\n
        "6.666666666666667"\n\n
        ">>> 20 // 3"\n
        "6"\n\n
        ">>> 20 % 3"\n
        "2"\n\n
        ">>> 3 ** 4"\n
        "81"\n\n
        ">>> pow(3, 4)"\n
        "81"\n\n
        ">>> pow(3, 4, 27)"\n
        "0"\n\n
        ">>> 3 ** 150"\n
        "369988485035126972924700782451696644186473100389722973815184405301748249"\n\n
        "                                Системы счисления"\n
        "   Те, у кого в школе была информатика, знают, что числа могут быть представлены не только в десятичной системе счисления. К примеру, в компьютере используется двоичный код, и, к примеру, число 19 в двоичной системе счисления будет выглядеть как 10011. Также иногда нужно переводить числа из одной системы счисления в другую. Python для этого предоставляет несколько функций:\n"
        "   1)	int([object], [основание системы счисления]) - преобразование к целому числу в десятичной системе счисления. По умолчанию система счисления десятичная, но можно задать любое основание от 2 до 36 включительно."\n
        "   2)	bin(x) - преобразование целого числа в двоичную строку.\n"
        "   3)	hex(х) - преобразование целого числа в шестнадцатеричную строку.\n"
        "   4)	oct(х) - преобразование целого числа в восьмеричную строку.\n"
        "Примеры:\n"
        ">>> bin(19)"\n
        "0b10011"\n\n
        ">>> oct(19)"\n
        "0o23"\n\n
        ">>> hex(19)"\n
        "0x13"\n
        ">>> 0b10011  (Так тоже можно записывать числовые константы)"\n
        "19"\n\n
        ">>> int('10011', 2)"\n\n
        "19"\n
        ">>> int('0b10011', 2)"\n
        "19"\n

    </string>
    <string name="lessonpy_4">
        Конструкция if/else.
Устловная конструкция if/elif/else (ее еще иногда называют оператором ветвления) – основной инструмент выбора в Python. Проще говоря, она выбирает, какое действие следует выполнить, в зависимости от значения переменных в момент проверки условия.
Синтаксис инструкции if.
Сначала записывается часть if с условным выражением, далее могут следовать одна или более необязательных частей elif,и , наконец, необязательная часть else. Общая форма записи условной части инструкции if выглядит следующим образом:
If 1:
	print('true')
else:
	print('false')

true
Чуть более сложный пример (его результат будет зависеть от того, что ввел пользователь):
a = int(input())
if a>5:
	print('High')
elif 5>=a >= -5
	print('Mid')
else:
	print('low')

    </string>
    <string name="lessonC1">
        "                                    Ввод в С++"\n\n
        "   В С++ разработана новая библиотека ввода-вывода iostream, использующая концепцию объектно-ориентированного программирования."
        "Библиотека iostream определяет три стандартных потока:\n\n"
        "   1) cin - стандартный входной поток (stdin в С)\n\n"
        "   2) cout - стандартный выходной поток (stdout в С)\n\n"
        "   3) cerr - стандартный поток вывода сообщений об ошибках (stderr в С)\n\n"
        "                                    Ввод информации."\n
        "cin >> идентификатор;"\n\n
        "   При этом из входного потока читается последовательность символов до пробела, затем эта последовательность преобразуется к типу идентификатора, и получаемое значение помещается в идентификатор:"\n\n
            "int n;"\n
            "cin >> n;"\n\n
        "Возможно многократное назначение потоков:"\n\n
        "    cin >> переменная1 >> переменная2 >>...>> переменная;"\n\n
        "   При наборе данных на клавиатуре значения для такого оператора должны быть разделены символами (пробел, /n, /t)."\n\n
            "int n;"\n
            "char j;"\n
            "cin >> n >> j;"\n\n
        "   Особого внимания заслуживает ввод символьных строк. По умолчанию потоковый ввод cin вводит строку до пробела, символа табуляции или перевода строки."
    </string>

    <string name="lessonja_2">
        "                   Математические операторы в Java.\n\n"
        "Из главных можно выделить следущие операторы: +, -, /, //, %, **.\n\n"
        "Сложение это знак + \n Вычитание это знак - \n Деление это знак / \n Умножение это знак *\n Возведение в степень это знак ** \n Остаток от деления %  \n\n"
        "Также можно вместо строчки: a = a+n;\n писать: a+=n;\n\n"
        "Вместо строчек: \n a = a-1\n a-=1 \n Можно написать a--"
    </string>
    <string name="lessonc_2">
        "                   Математические операторы в C++.\n\n"
        "Из главных можно выделить следущие операторы: +, -, /, //, %, **.\n\n"
        "Сложение это знак + \n Вычитание это знак - \n Деление это знак / \n Умножение это знак *\n Возведение в степень это знак ** \n Остаток от деления %  \n\n"
        "Также можно вместо строчки:\n\n a = a+n;\n писать: a+=n;\n\n"
        "Вместо строчек: \n\n a = a-1\n a-=1 \n\n Можно написать a-- или --а"
    </string>

    <string name="lessonja_3">
        "                               Функции в Java."\n\n
        "   Функция — это небольшая программа, которая выполняет определённые действия при вызове функции по имени.
        Написание функций относят к процедурному подходу в программировании.
        Различают два основных вида функций:
            1)Функция, которая что-то возвращает;

            public class Main {
                public static int func(){
                    int n = 10;
                    return n;
                }
                public static void main(String[] args) {}
            }
            2)Функция, которая ничего не возвращает;
                public class Main {

                    public static void func1(){
                        System.out.println("Привет из функции!");
                    }

                    public static void main(String[] args) {}
                }

        Запомните: переменная созданная в функции,  умирает после завершения функции и более не     существует!"
    </string>
    <string name="lessonc_3">
        "                           Функции в C++"\n\n
        "   Функции — это блоки кода, выполняющие определенные операции.\n
        Функции полезны для инкапсуляции основных операций в едином блоке, который может многократно использоваться. В идеальном случае имя этого блока должно четко описывать назначение функции.\n
        Следующая функция принимает два целых числа от вызывающего объекта и возвращает их сумм:

        int sum(int a, int b)
        {
            return a + b;
        }

        Функцию можно вызывать или вызыватьиз любого числа мест в программе.\n
        Длина функции практически не ограничена, однако для максимальной эффективности кода целесообразно использовать функции, каждая из которых выполняет одиночную, четко определенную задачу.\n
        Сложные алгоритмы лучше разбивать на более короткие и простые для понимания функции, если это возможно."
    </string>
    <string name="lessonc_4">
        "                           Циклы в С++."\n\n
        "Цикл for"\n\n
        "Если мы знаем точное количество действий (итераций) цикла, то можем использовать цикл for. Синтаксис его выглядит так:\n\n"
        "   for (действие до начала цикла;"\n
        "       условие продолжения цикла;"\n
        "       действия в конце каждой итерации цикла) {"\n
        "           инструкция цикла;"\n
        "           инструкция цикла 2;"\n
        "           инструкция цикла N;"\n
        "   }\n\n"
        "Существует частный случай этой записи:"\n\n
        "    for (счетчик = значение; счетчик меньше значение; шаг цикла) {"\n
        "        тело цикла;"\n
        "    }\n\n"
        "Цикл while"\n
        "Когда мы не знаем, сколько итераций должен произвести цикл, нам понадобится цикл while или do...while. Синтаксис цикла while в C++ выглядит следующим образом.\n\n"
        "    while (Условие) {"\n
        "        Тело цикла;"\n
        "    }"\n
    </string>
    <string name="lessonJA_4">
        "                              Циклы в Java"\n\n
        "Рассмотрим циклы в Java. В этом языке программирования их есть несколько типов:"\n\n
        "    1) while — цикл с предусловием;"\n
        "    2) do..while — цикл с постусловием;"\n
        "    3) for — цикл со с`четчиком (цикл для);"\n
        "    4) for each.. — цикл “для каждого…” — разновидность for для перебора коллекции элементов."\n\n
        "while, do.. while и for можно использовать в качестве безусловных циклов."\n\n
        "Цикл while:"\n\n
        "    while (expression) {"\n
        "        statement(s)"\n
        "    }\n\n"
        "Цикл do...while:"\n\n
        "    do {"\n
        "         statement(s)"\n
        "    } while (expression);\n\n"
        "Цикл for:"\n\n
        "    for (initialization; termination; increment) {"\n
        "        statement(s)"\n
        "    }\n\n"
        "Цикл for each:"\n\n
        "    for (Type var : vars) {"\n
        "        statement(s)"\n
        "    }"\n
    </string>
    <string name="lessonpy_5">
        "                                       Массивы в Python.\n\n"
        "Массив — это специальная переменная, которая может содержать более чем одно значение.Массив может содержать много значений под одним именем, и вы так же можете получить доступ к значениям по индексу.\n
        Используйте метод len() чтобы вернуть длину массива (число элементов массива). Чтобы получить доступ к элемменту массива, нужно сослаться  на его индекс.\n
        print(x[i])\n"
        "Чтобы получить длину массива, нужно использовать len()\n"
        "Добавление элементов массива\n
        Вы можете использовать метод append() для добавления элементов в массив.\n
        Удаление элементов массива\n
        Используйте метод pop() для того, чтобы удалить элементы из массива. Так же вы можете использовать метод remove() для того, чтобы убрать элемент массива. Примечание: Метод remove() удаляет только первое вхождение указанного значения.\n
        В Python есть набор встроенных методов, которые вы можете использовать при работе с lists/arrays.\n\n
        append() - Добавляет элементы в конец списка
        clear() - Удаляет все элементы в списке
        copy() - Возвращает копию списка
        count() - Возвращает число элементов с
            определенным значением
        extend() - Добавляет элементы списка в конец
            текущего списка
        index() - Возвращает индекс первого элемента с
            определенным значением
        insert() - Добавляет элемент в определенную
            позицию
        pop() - Удаляет элемент по индексу
        remove() - Убирает элементы по значению
        reverse() - Разворачивает порядок в списке
        sort() - Сортирует список

        "

    </string>
    <string name="lessonja_5">
        Массив — это структура данных, в которой хранятся элементы одного типа.
    Его можно представить, как набор пронумерованных ячеек, в каждую из которых можно поместить какие-то данные (один элемент данных в одну ячейку).
    Доступ к конкретной ячейке осуществляется через её номер. Номер элемента в массиве также называют индексом.
    Как и любой другой объект, создать массив Java, то есть зарезервировать под него место в памяти, можно с помощью оператора new. Делается это так:
    new typeOfArray [length];
     Обычно массив сначала объявляют, а потом создают, например:\n\n
        int[] myArray;
        myArray = new int[10];\n\n
    Однако гораздо чаще массив создают сразу после объявления с помощью такого сокращённого синтаксиса:\n\n
        int[] myArray = new int[10];\n\n
    Длина массива в Java\n\n
    Как мы уже говорили выше, длина массива — это количество элементов, под которое рассчитан массив. Длину массива нельзя изменить после его создания.\nОбратите внимание: в Java элементы массива нумеруются с нуля. То есть, если у нас есть массив на 10 элементов, то первый элемент массива будет иметь индекс 0, а последний — 9. Инициализацию также можно провести по-другому, совместив с инициализацией и объявлением:\n
    String[] seasons  = new String[] {"Winter", "Spring", "Summer", "Autumn"};
    Более того, оператор new можно опустить:\n\n
    String[] seasons  = {"Winter", "Spring", "Summer", "Autumn"};\n\n
    Вывести элементы массива на экран (то есть, в консоль) можно, например, с помощью цикла for.\n\n
        String[] seasons  = new String[] {"Winter", "Spring", "Summer", "Autumn"};
        for (int i = 0; 4 > i; i++) {
            System.out.println(seasons[i]);
        }\n\n
    Для работы с массивами в Java есть класс java.util.Arrays (arrays на английском и означает “массивы”). В целом с массивами чаще всего проделывают следующие операции: заполнение элементами (инициализация), извлечение элемента (по номеру), сортировка и поиск.

        "
    </string>
    <string name="lessonc_5">
        "   Массив это структура данных, представленная в виде группы ячеек одного типа, объединенных под одним единым именем. \n   Массивы используются для обработки большого количества однотипных данных. Имя массива является указателем. Отдельная ячейка данных массива называется элементом массива.  Элементами массива могут быть  данные любого типа. \n\nМассивы могут иметь как одно, так и более одного измерений. В зависимости от количества измерений массивы делятся на одномерные массивы, двумерные массивы, трёхмерные массивы и так далее до n-мерного массива.
        Одномерный массив — массив, с одним параметром, характеризующим количество элементов одномерного массива. Фактически одномерный массив — это массив, у которого может быть только одна строка, и n-е количество столбцов. Столбцы в одномерном массиве — это элементы массива.\n\n
        Всегда сразу после имени массива идут квадратные скобочки, в которых задаётся размер одномерного массива, этим массив и отличается от всех остальных переменных.
        Размер массива можно не указывать только при его инициализации, при обычном объявлении массива обязательно нужно указывать размер массива. Инициализация одномерного массива выполняется в фигурных скобках после знака равно, каждый элемент массива отделяется от предыдущего запятой.\n\n
        int a[]={5,-12,-12,9,10,0,-9,-12,-1,23,65,64,11,43,39,-15};\n\n
        Для вода элемента в массив можно использовать цикл for:
        for (int i=0; X>i; i++) {
        //фрагмент ввода;

        "
    </string>
    <string name="lessonpy_6">
        "Взятие элемента по индексу
Как и в других языках программирования, взятие по индексу. Как и во многих других языках, нумерация элементов начинается с нуля. При попытке доступа к несуществующему индексу возникает ошибка. взять элемент по индексу можно и у других типов: строк, кортежей.
В Python также поддерживаются отрицательные индексы, при этом нумерация идёт с конца.
Срезы
В Python, кроме индексов, существуют ещё и срезы. Параметры могут быть как положительные, так и отрицательные. Также с помощью срезов можно не только извлекать элементы, но и добавлять и удалять элементы (разумеется, только для изменяемых последовательностей).
"
    </string>
    <string name="lessonja_6">
        "
Взятие элемента по индексу
Как и в других языках программирования, взятие по индексу:
Как и во многих других языках, нумерация элементов начинается с нуля. При попытке доступа к несуществующему индексу возникает ошибка. Взять элемент по индексу можно и у других типов: строк, кортежей.
В Java также поддерживаются отрицательные индексы, при этом нумерация идёт с конца.
Срезы
В Java, кроме индексов, существуют ещё и срезы. Параметры могут быть как положительные, так и отрицательные. Также с помощью срезов можно не только извлекать элементы, но и добавлять и удалять элементы (разумеется, только для изменяемых последовательностей).
"
    </string>
    <string name="lessonc_6">
        "Например, у нас есть массив значений: 1 6 3 6 7 9. С каждым вторым значением нужно совершить какую-то операцию, к примеру вычесть 1. То есть подмножеством данного массива значений будет: 6 6 9. Вот у этих элементов вычитаем 1, получаем такое подмножество: 5 5 8. Весь же массив значений, после вычитания 1, будет выглядеть так: 1 5 3 5 7 8. Для того, чтобы такие операции было достаточно просто выполнять, в заголовочном файле valarray придумали механизм работы с подмножествами.
Есть 4-ре способа определения подмножеств в массивах значений, вот они:
1.	срезы,
2.	обобщенные срезы,
3.	отбор по логическому признаку,
4.	перечисляемые подмножества.
slice() — это функция, которая задает подмножество, диапазон значений массива, которые будут обработаны тем или иным образом. У функции slice() есть три параметра:
•	первый — индекс элемента массива, с которого будет начинаться выборка, в примере индекс равен 0, значит выборка начнется с первого элемента массива.
•	второй — количество элементов в массиве, которые подлежат выборке
•	третий — шаг выборки, в примере шаг равен 2, а значит каждый второй элемент попадет в подмножество.
"
    </string>
    <string name="lessonc_7">
        "Большинство компьютерных программ работают с файлами, и поэтому возникает необходимость создавать, удалять, записывать читать, открывать файлы. Под файлом понимается некоторая последовательность байтов, которая имеет своё, уникальное имя, например файл.txt. В одной директории не могут находиться файлы с одинаковыми именами. Под именем файла понимается не только его название, но и расширение, например: file.txt и file.dat . Существует такое понятие, как полное имя файлов – это полный адрес к директории файла с указанием имени файла, например: D:\docs\file.txt. Важно понимать эти базовые понятия, иначе сложно будет работать с файлами.
Для работы с файлами необходимо подключить заголовочный файл fstream. В fstream определены несколько классов и подключены заголовочные файлы ifstream — файловый ввод и  ofstream  — файловый вывод.
Файловый ввод/вывод аналогичен стандартному вводу/выводу, единственное отличие – это то, что ввод/вывод выполнятся не на экран, а в файл. Если ввод/вывод на стандартные устройства выполняется с помощью объектов cin и cout, то для организации файлового ввода/вывода достаточно создать собственные объекты, которые можно использовать аналогично операторам cin и cout.
Например, необходимо создать текстовый файл и записать в него строку Работа с файлами в С++. Для этого необходимо проделать следующие шаги:
1.	создать объект класса ofstream;
2.	связать объект класса с файлом, в который будет производиться запись;
3.	записать строку в файл;
4.	закрыть файл.
Почему необходимо создавать объект класса ofstream, а не класса ifstream? Потому, что нужно сделать запись в файл, а если бы нужно было считать данные из файла, то создавался бы объект класса ifstream.

	// создаём объект для записи в файл
ofstream /*имя объекта*/; // объект класса ofstream
Назовём объект – fout, Вот что получится:
	ofstream fout;
Для чего нам объект? Объект необходим, чтобы можно было выполнять запись в файл. Уже объект создан, но не связан с файлом, в который нужно записать строку.
	fout.open("cppstudio.txt"); // связываем объект с файлом
Через операцию точка получаем доступ к методу класса open(), в круглых скобочках которого указываем имя файла. Указанный файл будет создан в текущей директории с программой. Если файл с таким именем существует, то существующий файл будет заменен новым. Итак, файл открыт, осталось записать в него нужную строку. Делается это так:
	Fout "Работа с файлами в С++"; // запись строки в файл

Используя операцию передачи в поток совместно с объектом fout строка Работа с файлами в С++ записывается в файл. Так как больше нет необходимости изменять содержимое файла, его нужно закрыть, то есть отделить объект от файла.
	fout.close(); // закрываем файл
Итог – создан файл со строкой Работа с файлами в С++.
Шаги 1 и 2 можно объединить, то есть в одной строке создать объект и связать его с файлом. Делается это так:
	ofstream fout("cppstudio.txt"); // создаём объект класса ofstream и связываем его с файлом cppstudio.txt
"
    </string>
    <string name="lessonpy_7">
                "                           Файлы Python
        Файл — это всего лишь набор данных, сохраненный в виде последовательности битов на компьютере. Информация хранится в куче данных (структура данных) и имеет название «имя файла» (filename).

        В Python существует два типа файлов:

                Текстовые
                Бинарные
                                Открытие файла

        "1)  Метод open()"
            В Python есть встроенная функция open(). С ее помощью можно открыть любой файл на компьютере. Технически Python создает на его основе объект.Синтаксис следующий:

                f = open(file_name, access_mode)

        Режимы работы с файлами:

        "Режим"	        Описание
                r	    Только для чтения.
                w	    Только для записи. Создаст новый файл, если не найдет с указанным именем.
                rb	    Только для чтения (бинарный).
                wb	    Только для записи (бинарный). Создаст новый файл, если не найдет с указанным именем.
                r+	    Для чтения и записи.
                rb+	    Для чтения и записи (бинарный).
                w+	    Для чтения и записи. Создаст новый файл для записи, если не найдет с указанным именем.
                wb+	    Для чтения и записи (бинарный). Создаст новый файл для записи, если не найдет с указанным именем.
                a	    Откроет для добавления нового содержимого. Создаст новый файл для записи, если не найдет с указанным именем.
                a+	    Откроет для добавления нового содержимого. Создаст новый файл для чтения записи, если не найдет с указанным именем.
                ab	    Откроет для добавления нового содержимого (бинарный). Создаст новый файл для записи, если не найдет с указанным именем.
                ab+	    Откроет для добавления нового содержимого (бинарный). Создаст новый файл для чтения записи, если не найдет с указанным именем.

                                Закрытие файла
        Метод close()"
    </string>
    <string name="lessonja_7">
         "Класс File. Работа с файлами и каталогами"
        "Класс File, определенный в пакете java.io, не работает напрямую с потоками. Его задачей является управление информацией о файлах и каталогах. Хотя на уровне операционной системы файлы и каталоги отличаются, но в Java они описываются одним классом File.

        В зависимости от того, что должен представлять объект File - файл или каталог, мы можем использовать один из конструкторов для создания объекта:

            File(String путь_к_каталогу)
            File(String путь_к_каталогу, String имя_файла)
            File(File каталог, String имя_файла)
        Например:

            // создаем объект File для каталога
            File dir1 = new File("C://SomeDir");
            // создаем объекты для файлов, которые находятся в каталоге
            File file1 = new File("C://SomeDir", "Hello.txt");
            File file2 = new File(dir1, "Hello2.txt");

        Класс File имеет ряд методов, которые позволяют управлять файлами и каталогами."
        "   1)  boolean createNewFile(): создает новый файл по пути, который передан в конструктор. В случае удачного создания возвращает true, иначе false
            2)  boolean delete(): удаляет каталог или файл по пути, который передан в конструктор. При удачном удалении возвращает true.
            3)  boolean exists(): проверяет, существует ли по указанному в конструкторе пути файл или каталог. И если файл или каталог существует, то возвращает true, иначе возвращает false
            4)  String getAbsolutePath(): возвращает абсолютный путь для пути, переданного в конструктор объекта
            5)  String getName(): возвращает краткое имя файла или каталога
            6)  String getParent(): возвращает имя родительского каталога
            7)  boolean isDirectory(): возвращает значение true, если по указанному пути располагается каталог
            8)  boolean isFile(): возвращает значение true, если по указанному пути находится файл
            9)  boolean isHidden(): возвращает значение true, если каталог или файл являются скрытыми
            10) long length(): возвращает размер файла в байтах
            11) long lastModified(): возвращает время последнего изменения файла или каталога. Значение представляет количество миллисекунд, прошедших с начала эпохи Unix
            12) String[] list(): возвращает массив файлов и подкаталогов, которые находятся в определенном каталоге
            13) File[] listFiles(): возвращает массив файлов и подкаталогов, которые находятся в определенном каталоге
            14) boolean mkdir(): создает новый каталог и при удачном создании возвращает значение true
            15) boolean renameTo(File dest): переименовывает файл или каталог"
    </string>
    <string name="lessonja_8">
        "Одним из ключевых аспектов объектно-ориентированного программирования является наследование. С помощью наследования можно расширить функционал уже имеющихся классов за счет добавления нового функционала или изменения старого."
    "И, возможно, впоследствии мы захотим добавить еще один класс, который описывает сотрудника предприятия - класс Employee. Так как этот класс реализует тот же функционал, что и класс Person, поскольку сотрудник - это также и человек, то было бы рационально сделать класс Employee производным (наследником, подклассом) от класса Person, который, в свою очередь, называется базовым классом, родителем или суперклассом:

            class Employee extends Person{
                public Employee(String name){
                    super(name);    // если базовый класс определяет конструктор
                                    //  то производный класс должен его вызвать
                }
            }

        Чтобы объявить один класс наследником от другого, надо использовать после имени класса-наследника ключевое слово extends, после которого идет имя базового класса. Для класса Employee базовым является Person, и поэтому класс Employee наследует все те же поля и методы, которые есть в классе Person.
Если в базовом классе определены конструкторы, то в конструкторе производного классы необходимо вызвать один из конструкторов базового класса с помощью ключевого слова super. Например, класс Person имеет конструктор, который принимает один параметр. Поэтому в классе Employee в конструкторе нужно вызвать конструктор класса Person. То есть вызов super(name) будет представлять вызов конструктора класса Person.
При вызове конструктора после слова super в скобках идет перечисление передаваемых аргументов. При этом вызов конструктора базового класса должен идти в самом начале в конструкторе производного класса. Таким образом, установка имени сотрудника делегируется конструктору базового класса.
Причем даже если производный класс никакой другой работы не производит в конструкторе, как в примере выше, все равно необходимо вызвать конструктор базового класса."
    </string>
    <string name="lessonc_8">
        "Что такое наследование?

Наследование является одним из основополагающих принципов ООП. В соответствии с ним, класс может использовать переменные и методы другого класса как свои собственные.

Класс, который наследует данные, называется подклассом (subclass), производным классом (derived class) или дочерним классом (child). Класс, от которого наследуются данные или методы, называется суперклассом (super class), базовым классом (base class) или родительским классом (parent). Термины “родительский” и “дочерний” чрезвычайно полезны для понимания наследования. Как ребенок получает характеристики своих родителей, производный класс получает методы и переменные базового класса.

Наследование полезно, поскольку оно позволяет структурировать и повторно использовать код, что, в свою очередь, может значительно ускорить процесс разработки. Несмотря на это, наследование следует использовать с осторожностью, поскольку большинство изменений в суперклассе затронут все подклассы, что может привести к непредвиденным последствиям.
        Типы наследования

В C ++ есть несколько типов наследования:


публичный (public)- публичные (public) и защищенные (protected) данные наследуются без изменения уровня доступа к ним;
защищенный (protected) — все унаследованные данные становятся защищенными;
приватный (private) — все унаследованные данные становятся приватными."
    </string>
    <string name="lessonpy_8">
        "Наследование
        Наследование подразумевает то, что дочерний класс содержит все атрибуты родительского класса, при этом некоторые из них могут быть переопределены или добавлены в дочернем. Например, мы можем создать свой класс, похожий на словарь:

            >>>
            >>> class Mydict(dict):
            ...     def get(self, key, default = 0):
            ...         return dict.get(self, key, default)
            ...
            >>> a = dict(a=1, b=2)
            >>> b = Mydict(a=1, b=2)

        Класс Mydict ведёт себя точно так же, как и словарь, за исключением того, что метод get по умолчанию возвращает не None, а 0.

            >>>
            >>> b['c'] = 4
            >>> print(b)
            {'a': 1, 'c': 4, 'b': 2}
            >>> print(a.get('v'))
            None
            >>> print(b.get('v'))
            0"
    </string>
    <string name="lessonc_9">
        "set — это контейнер, который автоматически сортирует добавляемые элементы в порядке возрастания. Но при добавлении одинаковых значений, set будет хранить только один его экземпляр. По другому его еще называют множеством.
        multiset — это контейнер, который также будет содержать элементы в отсортированном порядке при добавлении, но он хранит повторяющееся элементы, по сравнению с множеством set. Часто его называют мультимножество.
        "
    </string>
    <string name="lessonpy_9">
                "Что такое множество?
        Множество в python - "контейнер", содержащий не повторяющиеся элементы в случайном порядке. Множества удобно использовать для удаления повторяющихся элементов. С множествами можно выполнять множество операций: находить объединение, пересечение…

        len(s) - число элементов в множестве (размер множества).
        x in s - принадлежит ли x множеству s.
        set.isdisjoint(other) - истина, если set и other не имеют общих элементов.
        set == other - все элементы set принадлежат other, все элементы other принадлежат set.
        set.issubset(other)  все элементы set принадлежат other.
        set.issuperset(other)  аналогично.
        set.union(other, …)  объединение нескольких множеств.
        set.intersection(other, ...)  пересечение.
        set.difference(other, ...)  множество из всех элементов set, не принадлежащие ни одному из other.
        set.symmetric_difference(other);  множество из элементов, встречающихся в одном множестве, но не встречающиеся в обоих.
        set.copy()  копия множества.

        И операции, непосредственно изменяющие множество:

        set.update(other, ...);  объединение.
        set.intersection_update(other, ...);  пересечение.
        set.difference_update(other, ...);  вычитание.
        set.symmetric_difference_update(other);  множество из элементов, встречающихся в одном множестве, но не встречающиеся в обоих.
        set.add(elem) - добавляет элемент в множество.
        set.remove(elem) - удаляет элемент из множества. KeyError, если такого элемента не существует.
        set.discard(elem) - удаляет элемент, если он находится в множестве.
        set.pop() - удаляет первый элемент из множества. Так как множества не упорядочены, нельзя точно сказать, какой элемент будет первым.
        set.clear() - очистка множества.
                                                frozenset
        Единственное отличие set от frozenset заключается в том, что set - изменяемый тип данных, а frozenset - нет. Примерно похожая ситуация с списками и кортежами."
    </string>
    <string name="lessonja_9">
        <b>Множества: Set, HashSet, LinkedHashSet, TreeSet</b>
            HashSet
            TreeSet
            SortedSet
        HashSet, TreeSet и LinkedHashSet относятся к семейству Set. В множествах Set каждый элемент хранится только в одном экземпляре, а разные реализации Set используют разный порядок хранения элементов. В HashSet порядок элементов определяется по сложному алгоритму. Если порядок хранения для вас важен, используйте контейнер TreeSet, в котором объекты хранятся отсортированными по возрастанию в порядке сравнения или LinkedHashSet с хранением элементов в порядке добавления.

        Множества часто используются для проверки принадлежности, чтобы вы могли легко проверить, принадлежит ли объект заданному множеству, поэтому на практике обычно выбирается реализация HashSet, оптимизированная для быстрого поиска.

        В Android 11 (R) обещают добавить несколько перегруженных версий метода of(), которые являются частью Java 8.

        HashSet
        Название Hash… происходит от понятия хэш-функция. Хэш-функция — это функция, сужающая множество значений объекта до некоторого подмножества целых чисел. Класс Object имеет метод hashCode(), который используется классом HashSet для эффективного размещения объектов, заносимых в коллекцию. В классах объектов, заносимых в HashSet, этот метод должен быть переопределен (override).

        Имеет два основных конструктора (аналогично ArrayList):

            // Строит пустое множество
            public HashSet()

            // Строит множество из элементов коллекции
            public HashSet(Collection c)
            Методы
            public Iterator iterator()
            public int size()
            public boolean isEmpty()
            public boolean contains(Object o)
            public boolean add(Object o)
            public boolean addAll(Collection c)
            public Object[] toArray()
            public boolean remove(Object o)
            public boolean removeAll(Collection c)
            public boolean retainAll(Collection c) - (retain — сохранить). Выполняет операцию "пересечение множеств".
            public void clear()
            public Object clone()"
    </string>
    <string name="lessonjalink1">
        "Посмотреть видео в ютубе"\n
        "<a href="https://www.youtube.com/watch?v=Y2iB_DwdyfM">https://www.youtube.com/watch?v=Y2iB_DwdyfM</a>"\n\n
    </string>
    <string name="lessonpylink1">
        "Посмотреть видео в ютубе"\n
        "<a href="https://www.youtube.com/watch?v=wuErNtUcfhg">https://www.youtube.com/watch?v=wuErNtUcfhg</a>"\n\n"
    </string>
    <string name="lessonclink1">
        "Посмотреть видео в ютубе"\n
        "<a href="https://www.youtube.com/watch?v=_x7IkSM7tsU">https://www.youtube.com/watch?v=_x7IkSM7tsU</a>"\n\n"
    </string>
    <string name="lessonjalink2">
        "Посмотреть видео в ютубе"\n
        "<a href="https://www.youtube.com/watch?v=ZVwoqF_z8gY">https://www.youtube.com/watch?v=ZVwoqF_z8gY</a>"\n\n
    </string>
    <string name="lessonpylink2">
        "Посмотреть видео в ютубе"\n
        "<a href="https://www.youtube.com/watch?v=g-4JbaY-yWU">https://www.youtube.com/watch?v=g-4JbaY-yWU</a>"\n\n"
    </string>
    <string name="lessonclink2">
        "Посмотреть видео в ютубе"\n
        "<a href="https://www.youtube.com/watch?v=-orgY_sGY6Y">https://www.youtube.com/watch?v=-orgY_sGY6Y</a>"\n\n"
    </string>
    <string name="lessonjalink3">
        "Посмотреть видео в ютубе"\n
        "<a href="https://www.youtube.com/watch?v=ROomaUIke2c">https://www.youtube.com/watch?v=ROomaUIke2c</a>"\n\n
    </string>
    <string name="lessonpylink3">
        "Посмотреть видео в ютубе"\n
        "<a href="https://www.youtube.com/watch?v=Zb3lF4qfElA">https://www.youtube.com/watch?v=Zb3lF4qfElA</a>"\n\n"
    </string>
    <string name="lessonclink3">
        "Посмотреть видео в ютубе"\n
        "<a href="https://www.youtube.com/watch?v=sNvjOSmtdnY">https://www.youtube.com/watch?v=sNvjOSmtdnY</a>"\n\n"
    </string>
    <string name="lessonjalink4">
        "Посмотреть видео в ютубе"\n
        "<a href="https://www.youtube.com/watch?v=y3Xu5o6Pxfg">https://www.youtube.com/watch?v=y3Xu5o6Pxfg</a>"\n\n
    </string>
    <string name="lessonpylink4">
        "Посмотреть видео в ютубе"\n
        "<a href="https://www.youtube.com/watch?v=sZ0EIwgLblY">https://www.youtube.com/watch?v=sZ0EIwgLblY</a>"\n\n"
    </string>
    <string name="lessonclink4">
        "Посмотреть видео в ютубе"\n
        "<a href="https://www.youtube.com/watch?v=Fh3huPx-kPI">ehjr1gdbd</a>"\n\n"
    </string>
    <string name="lessonjalink5">
        "Посмотреть видео в ютубе"\n
        "<a href="https://www.youtube.com/watch?v=li86TEAEhYM">https://www.youtube.com/watch?v=li86TEAEhYM</a>"\n\n
    </string>
    <string name="lessonpylink5">
        "Посмотреть видео в ютубе"\n
        "<a href="https://www.youtube.com/watch?v=-qfYT_9reC4">https://www.youtube.com/watch?v=-qfYT_9reC4</a>"\n\n"
    </string>
    <string name="lessonclink5">
        "Посмотреть видео в ютубе"\n
        "<a href="https://www.youtube.com/watch?v=miIbncBEn9c">https://www.youtube.com/watch?v=miIbncBEn9c</a>"\n\n"
    </string>
    <string name="lessonjalink6">
        "Посмотреть видео в ютубе"\n
        "<a href="https://www.youtube.com/watch?v=li86TEAEhYM">https://www.youtube.com/watch?v=li86TEAEhYM</a>"\n\n
    </string>
    <string name="lessonpylink6">
        "Посмотреть видео в ютубе"\n
        "<a href="https://www.youtube.com/watch?v=-qfYT_9reC4">https://www.youtube.com/watch?v=-qfYT_9reC4</a>"\n\n"
    </string>
    <string name="lessonclink6">
        "Посмотреть видео в ютубе"\n
        "<a href="https://www.youtube.com/watch?v=miIbncBEn9c">https://www.youtube.com/watch?v=miIbncBEn9c</a>"\n\n"
    </string>
    <string name="lessonjalink7">
        "Посмотреть видео в ютубе"\n
        "<a href="https://www.youtube.com/watch?v=gbP_nrABqEc">https://www.youtube.com/watch?v=gbP_nrABqEc</a>"\n\n
    </string>
    <string name="lessonpylink7">
        "Посмотреть видео в ютубе"\n
        "<a href="https://www.youtube.com/watch?v=oRr_bEXJbV0">https://www.youtube.com/watch?v=oRr_bEXJbV0</a>"\n\n"
    </string>
    <string name="lessonclink7">
        "Посмотреть видео в ютубе"\n
        "<a href="https://www.youtube.com/watch?v=GGwa4Co-15M">https://www.youtube.com/watch?v=GGwa4Co-15M</a>"\n\n"
    </string>
    <string name="lessonjalink8">
        "Посмотреть видео в ютубе"\n
        "<a href="https://www.youtube.com/watch?v=28NP_V2yc60">https://www.youtube.com/watch?v=28NP_V2yc60</a>"\n\n
    </string>
    <string name="lessonpylink8">
        "Посмотреть видео в ютубе"\n
        "<a href="https://www.youtube.com/watch?v=bmtMUWWFRIk">https://www.youtube.com/watch?v=bmtMUWWFRIk</a>"\n\n"
    </string>
    <string name="lessonclink8">
        "Посмотреть видео в ютубе"\n
        "<a href="https://www.youtube.com/watch?v=O7ruEWCa7zc">https://www.youtube.com/watch?v=O7ruEWCa7zc</a>"\n\n"
    </string>
    <string name="lessonjalink9">
        "Посмотреть видео в ютубе"\n
        "<a href="https://www.youtube.com/watch?v=izmLgjAg6co">https://www.youtube.com/watch?v=izmLgjAg6co</a>"\n\n
    </string>
    <string name="lessonpylink9">
        "Посмотреть видео в ютубе"\n
        "<a href="https://www.youtube.com/watch?v=KMGRXDxUw18">https://www.youtube.com/watch?v=KMGRXDxUw18</a>"\n\n"
    </string>
    <string name="lessonclink9">
        "Посмотреть видео в ютубе"\n
        "<a href="https://www.youtube.com/watch?v=N97grHs2fj4">https://www.youtube.com/watch?v=N97grHs2fj4</a>"\n\n"
    </string>

</resources>